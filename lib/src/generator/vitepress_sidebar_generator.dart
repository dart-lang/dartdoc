// Copyright (c) 2024, the Dart project authors. Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

import 'package:dartdoc/src/generator/vitepress_paths.dart';
import 'package:dartdoc/src/model/model.dart';

/// Generates the `.vitepress/generated/api-sidebar.ts` TypeScript file that
/// VitePress uses for sidebar navigation.
///
/// Traverses the [PackageGraph] model to produce a structured sidebar with:
/// - Library-level groups with `base` path deduplication
/// - Kind sub-groups (Classes, Exceptions, Enums, etc.)
/// - Category-based sub-grouping when >=2 categories exist in a kind group
/// - Adaptive collapse thresholds
/// - Multi-package nesting when multiple local packages exist
/// - Path-based routing for large projects (>100 total elements)
class VitePressSidebarGenerator {
  final VitePressPathResolver paths;

  VitePressSidebarGenerator(this.paths);

  /// Generates the full contents of `api-sidebar.ts`.
  String generate(PackageGraph packageGraph) {
    final localPackages = packageGraph.localPackages;
    final isMultiPackage = localPackages.length > 1;

    // Count total elements across all libraries.
    var totalElements = 0;
    for (final package in localPackages) {
      for (final library in package.publicLibrariesSorted) {
        totalElements += _countLibraryElements(library);
      }
    }

    final usePathRouting = totalElements > 100;
    final buf = StringBuffer();

    buf.writeln(
      '// AUTO-GENERATED by dartdoc-vitepress -- do not edit manually.',
    );
    buf.writeln("import type { DefaultTheme } from 'vitepress'");
    buf.writeln();

    if (usePathRouting) {
      _generatePathBased(buf, localPackages, isMultiPackage);
    } else {
      _generateFlat(buf, localPackages, isMultiPackage);
    }

    return buf.toString();
  }

  /// Generates a flat `SidebarItem[]` export for smaller projects.
  void _generateFlat(
    StringBuffer buf,
    List<Package> packages,
    bool isMultiPackage,
  ) {
    buf.writeln(
      'export const apiSidebar: DefaultTheme.SidebarItem[] = [',
    );

    for (final package in packages) {
      final libraries = package.publicLibrariesSorted;
      if (isMultiPackage) {
        // Wrap libraries in a package-level group.
        buf.writeln('  {');
        buf.writeln("    text: '${_escapeTs(package.name)}',");
        buf.writeln('    collapsed: false,');
        buf.writeln('    items: [');
        for (final library in libraries) {
          _writeLibraryGroup(buf, library, indent: 6);
        }
        buf.writeln('    ],');
        buf.writeln('  },');
      } else {
        for (final library in libraries) {
          _writeLibraryGroup(buf, library, indent: 2);
        }
      }
    }

    buf.writeln(']');
  }

  /// Generates a `Record<string, SidebarItem[]>` export for large projects
  /// with path-based sidebar routing.
  void _generatePathBased(
    StringBuffer buf,
    List<Package> packages,
    bool isMultiPackage,
  ) {
    buf.writeln(
      'export const apiSidebar: '
      'Record<string, DefaultTheme.SidebarItem[]> = {',
    );

    for (final package in packages) {
      for (final library in package.publicLibrariesSorted) {
        final base = '/api/${library.dirName}/';
        buf.writeln("  '${_escapeTs(base)}': [");
        _writeLibraryGroup(buf, library, indent: 4);
        buf.writeln('  ],');
      }
    }

    // Fallback overview sidebar for /api/.
    buf.writeln("  '/api/': [");
    for (final package in packages) {
      if (isMultiPackage) {
        buf.writeln('    {');
        buf.writeln("      text: '${_escapeTs(package.name)}',");
        buf.writeln('      items: [');
        for (final library in package.publicLibrariesSorted) {
          buf.writeln('        {');
          buf.writeln("          text: '${_escapeTs(library.name)}',");
          buf.writeln("          link: '/api/${library.dirName}/',");
          buf.writeln('        },');
        }
        buf.writeln('      ],');
        buf.writeln('    },');
      } else {
        for (final library in package.publicLibrariesSorted) {
          buf.writeln('    {');
          buf.writeln("      text: '${_escapeTs(library.name)}',");
          buf.writeln("      link: '/api/${library.dirName}/',");
          buf.writeln('    },');
        }
      }
    }
    buf.writeln('  ],');

    buf.writeln('}');
  }

  /// Writes a single library sidebar group with `base` path deduplication.
  void _writeLibraryGroup(
    StringBuffer buf,
    Library library, {
    required int indent,
  }) {
    final pad = ' ' * indent;
    final totalElements = _countLibraryElements(library);
    final libraryCollapsed = totalElements > 30;
    final base = '/api/${library.dirName}/';

    buf.writeln('$pad{');
    buf.writeln("$pad  text: '${_escapeTs(library.name)}',");
    buf.writeln("$pad  base: '${_escapeTs(base)}',");
    buf.writeln('$pad  collapsed: $libraryCollapsed,');
    buf.writeln('$pad  items: [');

    // Overview link (relative to base -> '/').
    buf.writeln("$pad    { text: 'Overview', link: '/' },");

    // Kind groups in the specified order.
    _writeKindGroup(
      buf,
      library,
      'Classes',
      library.publicClassesSorted,
      indent: indent + 4,
      collapseThreshold: 8,
    );
    _writeKindGroup(
      buf,
      library,
      'Exceptions',
      library.publicExceptionsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
    );
    _writeKindGroup(
      buf,
      library,
      'Enums',
      library.publicEnumsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
    );
    _writeKindGroup(
      buf,
      library,
      'Mixins',
      library.publicMixinsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
    );
    _writeKindGroup(
      buf,
      library,
      'Extensions',
      library.publicExtensionsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
    );
    _writeKindGroup(
      buf,
      library,
      'Extension Types',
      library.publicExtensionTypesSorted,
      indent: indent + 4,
      collapseThreshold: 8,
    );
    _writeKindGroup(
      buf,
      library,
      'Functions',
      library.publicFunctionsSorted,
      indent: indent + 4,
      collapseThreshold: 10,
    );
    _writeKindGroup(
      buf,
      library,
      'Properties',
      library.publicPropertiesSorted,
      indent: indent + 4,
      collapseThreshold: 10,
    );
    _writeKindGroup(
      buf,
      library,
      'Constants',
      library.publicConstantsSorted,
      indent: indent + 4,
      collapseThreshold: 10,
    );
    _writeKindGroup(
      buf,
      library,
      'Typedefs',
      library.publicTypedefsSorted,
      indent: indent + 4,
      collapseThreshold: 8,
    );

    buf.writeln('$pad  ],');
    buf.writeln('$pad},');
  }

  /// Writes a kind group (e.g. "Classes") with optional category sub-grouping.
  ///
  /// Empty groups are omitted. If >=2 distinct categories exist among the
  /// elements, they are sub-grouped by category name. Uncategorized elements
  /// appear in an "Other" sub-group at the end.
  void _writeKindGroup(
    StringBuffer buf,
    Library library,
    String kindName,
    List<ModelElement> elements, {
    required int indent,
    required int collapseThreshold,
  }) {
    if (elements.isEmpty) return;

    final pad = ' ' * indent;
    final collapsed = elements.length > collapseThreshold;

    // Determine category distribution for sub-grouping.
    final categoryMap = <String, List<ModelElement>>{};
    final uncategorized = <ModelElement>[];

    for (final element in elements) {
      final categories = element.displayedCategories.toList();
      if (categories.isEmpty) {
        uncategorized.add(element);
      } else {
        // Use the first category for grouping.
        final categoryName = categories.first.name;
        categoryMap.putIfAbsent(categoryName, () => []).add(element);
      }
    }

    // Only sub-group when >=2 distinct categories exist.
    final distinctCategories = categoryMap.keys.toList()..sort();
    final useCategoryGrouping = distinctCategories.length >= 2;

    buf.writeln('$pad{');
    buf.writeln("$pad  text: '${_escapeTs(kindName)}',");
    buf.writeln('$pad  collapsed: $collapsed,');
    buf.writeln('$pad  items: [');

    if (useCategoryGrouping) {
      // Write category sub-groups.
      for (final categoryName in distinctCategories) {
        final categoryElements = categoryMap[categoryName]!;
        buf.writeln('$pad    {');
        buf.writeln("$pad      text: '${_escapeTs(categoryName)}',");
        buf.writeln('$pad      collapsed: false,');
        buf.writeln('$pad      items: [');
        for (final element in categoryElements) {
          _writeElementItem(buf, element, library, indent: indent + 8);
        }
        buf.writeln('$pad      ],');
        buf.writeln('$pad    },');
      }
      // Write uncategorized elements in "Other" sub-group.
      if (uncategorized.isNotEmpty) {
        buf.writeln('$pad    {');
        buf.writeln("$pad      text: 'Other',");
        buf.writeln('$pad      collapsed: false,');
        buf.writeln('$pad      items: [');
        for (final element in uncategorized) {
          _writeElementItem(buf, element, library, indent: indent + 8);
        }
        buf.writeln('$pad      ],');
        buf.writeln('$pad    },');
      }
    } else {
      // Flat list without category sub-grouping.
      for (final element in elements) {
        _writeElementItem(buf, element, library, indent: indent + 4);
      }
    }

    buf.writeln('$pad  ],');
    buf.writeln('$pad},');
  }

  /// Writes a single element sidebar item.
  ///
  /// Links are relative to the library's `base` path, so for an element
  /// at `/api/my_lib/MyClass` with base `/api/my_lib/`, the link is
  /// `/MyClass`.
  void _writeElementItem(
    StringBuffer buf,
    ModelElement element,
    Library library, {
    required int indent,
  }) {
    final pad = ' ' * indent;
    final url = paths.urlFor(element) ?? '/${element.name}';
    final base = '/api/${library.dirName}/';

    // Make link relative to the library base.
    String link;
    if (url.startsWith(base)) {
      link = '/${url.substring(base.length)}';
    } else {
      // Fallback: use absolute path.
      link = url;
    }

    buf.writeln(
      "$pad{ text: '${_escapeTs(element.name)}', link: '${_escapeTs(link)}' },",
    );
  }

  /// Counts the total number of documented public elements in a library.
  int _countLibraryElements(Library library) {
    return library.publicClassesSorted.length +
        library.publicExceptionsSorted.length +
        library.publicEnumsSorted.length +
        library.publicMixinsSorted.length +
        library.publicExtensionsSorted.length +
        library.publicExtensionTypesSorted.length +
        library.publicFunctionsSorted.length +
        library.publicPropertiesSorted.length +
        library.publicConstantsSorted.length +
        library.publicTypedefsSorted.length;
  }

  /// Escapes a string for use inside a TypeScript single-quoted string.
  static String _escapeTs(String value) {
    return value
        .replaceAll(r'\', r'\\')
        .replaceAll("'", r"\'")
        .replaceAll('\n', r'\n')
        .replaceAll('\r', r'\r');
  }
}
